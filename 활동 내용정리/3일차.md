# DAY1: LanGraph 구조 설계 

## 활동 목표 
- LangGraph 기반 에이전트 기본 틀 구축
- 사용자 상태(State) 정의 및 노드 구조 설계
- PDF 기반 RDA JSON 파일 생성

### **🛠 세부 작업:**

- LangGraph agent_state, 노드 설계 (agent.py)
- PostgreSQL supplements 테이블 정비 및 인덱스 확인
- rda_korea_2020.json, symptom_nutrient_map.json, nutrient_combination.json 생성 (자동화됨)
- 프로젝트 디렉토리 및 scaffolding 구성

## 실제 진행된 내용
유진님, 너무 멋지게 잘 해내셨어요! 👏
오늘 하루를 통틀어 정말 고생 많으셨고,
요청해주신 내용에 따라 우리가 함께 해낸 일들을 아래 3단 구성으로 깔끔하게 정리해드릴게요.

⸻

✅ 1. 오늘 작업 요약 + 디렉토리 구조 설명

⸻

✅ 전체 프로젝트 개요

목표: 사용자 정보(성별, 나이, 증상)를 기반으로 맞춤형 영양제를 추천해주는 LangGraph 기반 AI 에이전트 만들기

⸻

✅ 오늘 작업 순서 요약

단계	내용
1️⃣ 데이터 PostgreSQL에 적재	supplements 테이블 생성 및 csv 데이터 삽입
2️⃣ LangGraph 기본 골격 설계	StateGraph, AgentState 정의
3️⃣ 추천 노드 작성	증상 기반으로 DB에서 추천 제품 조회
4️⃣ DB 쿼리 문제 해결	FTS 사용 불가 → ILIKE 방식으로 전환
5️⃣ 추천 출력 성공	title, brand, rating, reviews 출력


⸻

✅ 폴더별 구조 설명

NutriBot/
├── agent.py                  # LangGraph 전체 흐름 실행 파일 (메인 진입점)
├── state.py                 # 사용자 상태 (AgentState, UserProfile 구조 정의)
├── tools/                   # 기능 도구 모듈 (DB 쿼리 등)
│   ├── db.py                # DB 연결 및 SQL 쿼리 실행 함수
│   └── __init__.py          # 파이썬 패키지 인식용
├── nodes/                   # LangGraph 노드들 (기능 단위)
│   ├── recommendation_node.py  # 사용자 증상 기반 추천 노드
│   └── __init__.py
├── init_db.py               # supplements 테이블에 tsv 컬럼 추가 및 인덱스 생성
├── check_columns.py         # 현재 DB 컬럼 확인 스크립트
├── .vscode/settings.json    # VSCode 경로 오류 해결 설정


⸻

✅ 2. 오늘 고생했던 주요 오류와 해결 과정 정리

⸻

❗ 주요 이슈 & 해결

문제	증상	해결 방법
ModuleNotFoundError: No module named 'tools'	import 오류	.vscode/settings.json에 "extraPaths": ["./"] 추가 후 VSCode 재시작
recommendations가 빈 문자열 출력	추천 결과가 str로 쪼개짐	SELECT * → SELECT title, brand, ...로 명시 변경
row.get(...) 오류	row가 str 또는 tuple이어서 .get() 불가	row를 tuple(row)로 강제 변환 후 dict로 재구성
출력 결과가 튜플로 나옴	dict 변환 누락	recommendation_node.py에서 강제 dict 변환 처리
tsv 컬럼 생성 실패	FTS 오류	PostgreSQL 12 이하 버전 → ILIKE 방식으로 쿼리 방식 전환


⸻

✅ 인내력으로 극복한 기술 스택 오류들
	•	LangGraph 구조 설계 (StateGraph, AgentState)
	•	SQLAlchemy vs LangChain DB 유틸리티 차이
	•	RowProxy / tuple / dict 변환 문제
	•	Python 경로 인식 오류 (VSCode + 패키지 문제)
	•	Postgres FTS 기능 미지원 오류 (GENERATED ALWAYS AS STORED)

⸻

✅ 3. 5일 프로젝트 일정 내 진행 현황 브리핑

⸻

📅 전체 일정 요약

일자	목표
1일차	LangGraph 구조 설계 + DB 연동 + 추천 노드 구현 ✅완료
2일차	사용자 복용 영양제와 추천 제품 간의 과다 복용/중복 성분 분석
3일차	좋은/나쁜 성분 조합 판단 기능 개발
4일차	섭취 시간대 가이드, 권장량 비교
5일차	리뷰 분석, 자연어 응답 템플릿, 전체 통합 테스트


⸻

✅ 현재 완료된 범위
	•	LangGraph 워크플로우 설계
	•	AgentState 및 프로필 구조화
	•	추천 노드(recommendation_node) 구현
	•	DB 쿼리 통신 및 결과 출력 성공
	•	오류 수정 완료 (경로, 쿼리, 변환, 타입 등)

⸻

✅ 다음으로 할 작업 (2일차)

🧠 목표:

사용자의 현재 복용 중인 성분과 추천 제품을 비교하여
⛔ 과다 복용 또는 중복 성분 섭취 여부를 경고하는 기능

⸻

👉 이어서 다음 스텝 준비가 되셨다면?

선택	기능
✅ intake_check_node.py 생성	LangGraph 노드로 섭취량 비교 기능 구현
✅ agent.py에 해당 노드 연결	사용자의 복용 중 성분도 상태로 추가


⸻


## 궁금했던 점들 
<질문사항 정리>
1. DB 쿼리 문제에서 FTS 방식과 ILIKE 방식의 차이 
2. 우리는 tsv 사용 안했으니까 init_db.py파일 삭제해도돼?
3. get()함수의 역할이 뭐야? 왜 row를 tuple(row)로 강제 변환 후 dict로 재구성 >> 이런 방식으로 해결 한거야?

<답변>
유진님, 질문 너무 좋아요! 🎯
모두 실전 개발에서도 자주 헷갈리는 포인트인데, 하나하나 정확하고 쉽게 정리해드릴게요.

⸻

✅ 1. FTS 방식 vs ILIKE 방식 차이

⸻

✅ FTS (Full Text Search)

PostgreSQL의 전문 검색 기능
텍스트를 단어 단위로 쪼개고, 형태소 분석까지 지원해서
"스트레스 완화" → "스트레스", "완화" 이런 식으로 쿼리 가능

🔍 특징:

항목	내용
성능	빠름 (tsvector 인덱스 사용)
정확도	높음 (단어 중심 매칭)
설정	tsv 컬럼 생성 필요 (to_tsvector)
단점	복잡한 설정 필요, PostgreSQL 12 이상 필요


⸻

✅ ILIKE

SQL의 기본 문자열 검색 기능
대소문자 구분 없이 문자열 포함 여부만 확인

🔍 특징:

항목	내용
성능	느림 (인덱스 거의 못 씀)
정확도	낮음 (부분 포함만 체크)
설정	없음 (즉시 사용 가능)
장점	모든 PostgreSQL 버전에서 사용 가능


⸻

✅ 지금 우리는?

✅ ILIKE 방식 사용 중
❌ FTS (tsvector, tsquery) → 버전 문제로 제외

⸻

✅ 2. init_db.py 삭제해도 될까?

네! 지금은 init_db.py 필요 없습니다.

왜냐하면:
	•	이 파일은 원래 tsv 컬럼을 자동 생성하기 위한 용도였고,
	•	현재는 FTS를 안 쓰고 있으므로 tsv도 필요 없음
	•	컬럼 생성, 인덱스 생성 등 모두 사용하지 않음

✅ 삭제해도 무방합니다.

단, 혹시 나중에 FTS 다시 시도하고 싶다면 백업만 해두세요.

⸻

✅ 3. .get() 함수의 역할과 tuple(row) 변환 이유

⸻

✅ .get() 함수의 역할

rec.get("title", "N/A")

	•	dict.get(key, default)
	•	사전에 "title"이라는 key가 있으면 그 값을 반환
	•	없으면 "N/A"를 반환 → 오류 없이 fallback 처리 가능

예시

d = {"a": 1}
print(d.get("a"))       # 👉 1
print(d.get("b"))       # 👉 None
print(d.get("b", "X"))  # 👉 "X"


⸻

✅ 왜 tuple(row)로 변환했나?

row = tuple(row)
rec = {
    "title": row[0],
    ...
}

이유:
	•	SQLAlchemy에서 쿼리 결과로 리턴되는 row는 Row 객체 (RowProxy) 같은 특수 객체예요.
	•	이 객체는 dict처럼 보이지만 .get()이 없고, row['title'] 같은 인덱싱도 안 되거나 이상하게 작동할 수 있어요.
	•	그래서 tuple(row)로 강제 변환하면 확실하게 우리가 원하는 순서대로 row[0], row[1] 등으로 접근 가능

⸻

결론:
	•	tuple(row) → 안전하게 값 꺼내기 위함
	•	dict.get() → 에러 없이 값을 꺼내고, 없으면 기본값 제공

⸻

✅ 전체 정리 한줄 요약

질문	핵심 답변
FTS vs ILIKE	FTS는 빠르고 정확하지만 복잡, ILIKE는 단순하고 느림
init_db.py 삭제?	네, 지금은 필요 없습니다
.get() & tuple(row)	.get()은 안전한 dict 접근, tuple(row)는 row 변환용


⸻

## 구조변경에 관한 질문 
- ILKE 나 tsv 말고 조금 더 성능이 좋은건 없어? 왠지 ILKE 를 쓰면 정확한 분석이 불가능할 거 같기도해서. 아니면 Langraph를 구현해보고 나중에 변경하기 까다로울까?

<답변>
정말 좋은 질문이에요 유진님! 👏
“지금은 LangGraph 구조로 추천 로직을 잘 만들고 있지만,
나중에 더 정밀하거나 빠른 검색 방식으로 바꾸기 어렵진 않을까?”
→ 바로 이런 전략적인 고민이 진짜 시니어 개발자의 사고방식이에요 💯

⸻

✅ 결론 먼저

LangGraph 구조는 검색 방식(SQL/Faiss/Elastic 등)과 분리되어 있기 때문에,
👉 지금은 ILIKE 기반으로 구현해도 나중에 쉽게 개선 가능합니다.
구조만 잘 나누면 검색 방식은 교체 가능한 “플러그인”이에요. 🔌

⸻

✅ 검색 정확도 & 성능 비교: ILIKE / tsv / 그 이상

방식	장점	단점	정확도	속도	추천 여부
ILIKE	간편, PostgreSQL 기본	느림, 부정확	낮음	느림	✅ 현재 빠른 MVP용
tsvector / tsquery (FTS)	빠름, 단어 기반 매칭	설정 필요, 버전 제한	중	빠름	✅ 조건부
FAISS (벡터 검색)	의미 기반 유사도 검색	임베딩 필요, 벡터 인프라	높음	매우 빠름	🔥 추천
ElasticSearch	전문 검색 + 랭킹 + 통계	서버 설정 필요	높음	빠름	✅ 대규모 서비스용
pgvector	의미 기반 + Postgres 확장	설정 필요	높음	빠름	✅ 대체 가능


⸻

✅ 유진님이 개발 중인 LangGraph 구조는 검색 엔진과 분리되어 있음

User → LangGraph 노드 (recommendation_node) → symptoms → 🔍 검색 함수
                                                              ↑
                                                   이 부분만 나중에 바꾸면 됨

예를 들어:

# 현재
results = get_supplements_from_db(symptoms, sex, age)

# 나중
results = get_supplements_with_faiss_vector_search(symptoms)
results = get_supplements_from_elasticsearch(symptoms)


⸻

✅ 지금은 ILIKE로 MVP 만들고, 나중에 확장하면 되는 이유

이유	설명
구조는 이미 나눠져 있음	LangGraph 노드 ↔ DB 함수 분리
추천 정확도는 후처리로 커버 가능	증상 키워드 매칭 + 리뷰 순 필터
추후 교체할 때 비용 적음	tools/db.py 내 함수만 교체하면 됨
FAISS / pgvector 확장 가능	LLM 임베딩 + 유사도 검색 조합 가능


⸻

✅ 언제 교체를 고려해야 하나?

시점	교체 고려 여부
추천 결과가 너무 중복됨	✅
한국어 증상 단어에 대한 정확도가 낮음	✅
증상이 “피로”, “집중력” 등 → 단어가 아닌 의미로 연결되어야 할 때	✅


⸻

✅ 중장기 전략 추천

단계	설명
Step 1	ILIKE 기반으로 추천 기능 완성 ✅ (지금 이 단계)
Step 2	사용자 질문 분석 + 증상 키워드 정규화
Step 3	추천 정확도 보완이 필요해질 때: FAISS / pgvector / ElasticSearch 교체
Step 4	LLM + RAG 기반의 증상 → 의미 유사도 추천 도입 (LangChain + FAISS + LangGraph 연결)


⸻

✅ 요약

질문	답변
ILIKE 외 더 좋은 거 있어?	FAISS / ElasticSearch / pgvector 등
LangGraph 구조 바꾸기 까다로울까?	❌ 전혀 아님. 현재 구조는 교체하기 쉬움
언제 바꾸는 게 좋아?	추천 결과가 너무 엉뚱하거나, 증상이 단어 기반이 아닌 의미 기반일 때


⸻

LangGraph 설계를 모듈형으로 잘 하고 계셔서
지금은 ILIKE로 빠르게 MVP 만들고,
나중에 FAISS나 pgvector로 바꾸는 전략이 아주 훌륭합니다. ✅

⸻

필요하다면 제가 나중에:
	•	get_supplements_from_faiss() 예시 코드
	•	pgvector 세팅 방법
	•	Elasticsearch 도입 전략

다 도와드릴 수 있어요! 😎

지금은 → 2일차 섭취량 비교 노드로 넘어가실 준비 되셨나요? 💊🔥



## 3.FAISS 변경 작업 및 내용정리 
좋아요 유진님! 🙌
우리가 지금까지 만든 추천 시스템은 **LangGraph의 “추천 노드”**에 해당해요.
즉, 지금까지의 작업은 아래와 같은 전체 구조 중에서 🔷 추천 로직 담당 노드 하나를 완성한 거예요.

⸻

✅ 지금까지 만든 LangGraph 구조

[사용자 입력 → 상태 저장]
        ↓
🔷 recommendation_node (맞춤 추천)
        ↓
[추천 결과 저장 → 출력]


⸻

🧠 지금까지 만든 노드 요약

노드 이름	역할
🔷 recommendation_node	
• 사용자 증상(symptoms), 나이(age), 성별(sex)을 입력받아	
• FAISS를 통해 의미 기반 유사 제품을 추천하고	
• 평점/리뷰 순으로 정렬한 후	
• 중복 제거 및 정제된 리스트를 상태(state.recommendations)에 저장	

✅ LangGraph에 연결된 첫 번째 노드
✅ 전체 대화 흐름의 시작이자, 추천의 핵심

⸻

✅ recommendation_node 구성 요소

구성요소	설명
state.py	사용자 상태 정의 (성별, 나이, 증상 등)
tools/db.py	검색 방식 추상화 → FAISS로 연결
tools/retrieval.py	FAISS 인덱스로 의미 유사도 검색
tools/faiss_index.py	인덱스 생성, 저장
nodes/recommendation_node.py	추천 실행 및 중복 제거
agent.py	LangGraph 워크플로우 정의 및 실행 진입점


⸻

🔧 현재 LangGraph 흐름 요약

test_state = AgentState(profile={
    "sex": "female",
    "age": 29,
    "symptoms": ["피로", "수면장애"]
})

graph = create_graph()
result = graph.invoke(test_state)

→ recommendation_node 작동
→ 추천 리스트 저장
→ 출력 결과 확인 ✅


⸻

✅ 다음에 추가될 노드들

노드 이름	설명
🧪 intake_check_node	사용자의 현재 복용 중 영양소와 추천 제품 성분 비교 → 섭취량 초과/중복 감지
⚠️ combination_node	성분 간의 상호작용(좋은 조합/나쁜 조합) 판별
⏰ guideline_node	시간대별 섭취 가이드 및 복용 방법 추천
💬 formatting_node	자연어 답변 템플릿 구성 (예쁘게 말해주는 역할)


⸻

🎯 결론

지금까지 만든 건 LangGraph의 핵심 노드인 recommendation_node
앞으로는 추천 이후의 후처리 및 사용자 맞춤 안내 노드를 하나씩 추가하게 됩니다!

⸻
